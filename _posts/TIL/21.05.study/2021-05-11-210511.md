---
title:  "21.05.11 기록"
excerpt: "스프링과 자바 키워드, 백준 알고리즘 풀이"
categories:
  - TIL
  - Spring
  - Java
  - BAEKJOON
---


+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` ─ 4장. 자바가 확장한 객체 지향
  + Call By Value와 Call By Reference(Call By Address)의 차이
  + 추상 클래스와 추상 메서드의 특징
  + static 블록
    + 사실 패키지 또는 클래스가 처음 사용될 때 T메모리의 static 영역에 배치된다. (시작할 때 일단 다 로드되고 실행되는 것이 아니다.)
    + JUnit @BeforeClass 어노테이션
    + 인스턴스 블록

  <br />

+ 백준 알고리즘 [10818](https://www.acmicpc.net/problem/10818), [2562](https://www.acmicpc.net/problem/2562) 풀이 완료

  + 내가 푼 10818 풀이 (메모리 92.3MB, 시간 564ms로 통과)

  ```java

  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;

  public class B10818 {
      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          StringBuilder sb = new StringBuilder();
          StringTokenizer st;

          try {
              int N = Integer.parseInt(br.readLine());
              st = new StringTokenizer(br.readLine(), " ");
              int[] arr = new int[N];
              int max = -1_000_001;
              int min = 1_000_001;

              for(int i = 0; i < N; i++) {
                  arr[i] = Integer.parseInt(st.nextToken());
              }

              for(int i = 0; i < arr.length; i++) {
                  if(max < arr[i]) max = arr[i];
                  if(min > arr[i]) min = arr[i];
              }

              sb.append(min).append(" ").append(max);
              System.out.println(sb);

          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

<br />

  + [10818_해설](https://st-lab.tistory.com/43)을 참고한 풀이 (메모리 89.4MB, 시간 592ms로 통과)
    + 아래 풀이는 배열을 사용하지 않은 풀이이다.


  ```java

  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;

  public class B10818 {
      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          StringTokenizer st;

          try {
              Integer.parseInt(br.readLine());
              st = new StringTokenizer(br.readLine(), " ");

              int max = -1_000_001;
              int min = 1_000_001;

              while(st.hasMoreTokens()) {
                  int val = Integer.parseInt(st.nextToken());

                  if(val > max) max = val;
                  if(val < min) min = val;
              }

              System.out.println(min + " " + max);

          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  <br />

  +  내가 푼 2562 풀이 (메모리 16.6MB, 시간 152ms로 통과)

  ```java

  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;

  public class B2562 {
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            int max = 0;
            int cnt = 0;
            int[] arr = new int[9];

            for(int i = 0; i < arr.length; i++) {
                arr[i] = Integer.parseInt(br.readLine());

                if(arr[i] > max) {
                    max = arr[i];
                    cnt = i+1;
                }
            }
            System.out.println(max + "\n" + cnt);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
  ```
<br />

+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` check!
  + Call By Value와 Call By Reference(Call By Address)의 차이<br />
    : Call By Value는 변수에 저장된 값을 값 자체로 해석하는 반면, Call By Reference는 값을 주소로 해석한다.

  + 추상 클래스와 추상 메서드의 특징<br />
    : 추상 클래스는 인스턴스를 만들 수 없다. (= new 사용x) <br />
    : 추상 메서드는 하위 클래스에게 오버라이딩을 강제한다.<br />
    : 추상 메서드를 포함하는 클래스는 반드시 추상 클래스이다.

  + static 블록<br />
    : 클래스가 static 영역에 배치될 때 실행되는 코드이다.<br />
    : 배치될 때만 실행되기 때문에 딱 1번만 실행된다.<br />

    + JUnit의 @BeforeClass 어노테이션<br />
      : [JUnit](https://www.nextree.co.kr/p11104/) - 단위 테스트 프레임워크<br />
      : @BeforeClass - 테스트 시작 전에 딱 한 번만 실행시킨다.<br />

    + 인스턴스 블록
      : 인스턴스가 생성된 후 자동으로 실행되는 블록으로 생성될 때마다 실행된다.

    ```java
    public class InstanceBlockEx {
        public static void main(String[] args)
            new SayHello();
            new SayHello();
            new SayHello();
        }
    }
    class SayHello {
      {
          System.out.println("Hello");
      }

      {
          System.out.println("I can say HI, too");
      }
  }
    ```
