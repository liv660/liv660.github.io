---
title:  "21.05.06 study"
excerpt: "21.05.06 공부한 키워드 정리"
categories:
  - TIL
---


# 📝21.05.06 TIL
+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해`
  + 객체 지향 프로그램의 메모리 사용 방식(T메모리 구조)
  + main() 메서드가 실행 되기 전 JRE의 동작과 JVM의 전처리 과정
  + main()의 동작이 끝난 후 JRE와 JVM의 동작
  + '외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나, 그 역은 가능하다.'
  + Call By Value(값에 의한 전달) 이란?
  + 전역 변수를 사용하지 않는 이상, stack 영역의 메서드들은 서로의 지역 변수에 접근할 수 없다.
  + 전역 변수를 사용하는 것, 왜 좋지 않을까?

<br />

+ 백준 알고리즘 [2721](https://www.acmicpc.net/problem/2741), [2742](https://www.acmicpc.net/problem/2742), [11021](https://www.acmicpc.net/problem/11021) 풀이 완료

  + 11021 BufferedReader, BufferedWriter, StringTokenizer 사용하여 푼 풀이<br />
  + 1차 런타임 오류로 실패, 2차 시도에 성공<br />

  ```java
  import java.io.*;
  import java.util.StringTokenizer;

  public class B11021 {

    public static void main(String[] args) {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
      StringTokenizer st;

      try {
        int testCase = Integer.parseInt(br.readLine());

        for(int i = 1; i <= testCase; i++) {
          st = new StringTokenizer(br.readLine(), " ");
          bw.write( "Case #" + i +": " + (Integer.parseInt(st.nextToken())+Integer.parseInt(st.nextToken())) + "\n");
        }

        bw.flush();
        bw.close();
        br.close();

      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
  ```

<br />

+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` Check!
  + 객체 지향 프로그램의 메모리 사용 방식(T메모리 구조)<br/>
    : 코드 실행 영역, Static 영역, Stack 영역, Heap 영역으로 구성

  + main() 메서드가 실행 되기 전 JRE의 동작과 JVM의 전처리 과정<br/>
    + JRE <br/>
      : main()의 존재를 확인 후, JVM을 부팅시킨다.<br />
    + JVM <br />
      -java.lang 패키지를 스태틱 영역에 배치한다. <br />
      -import된 패키지를 스태틱 영역에 배치한다. <br />
      -프로그램 상의 모든 클래스를 스태틱 영역에 배치한다.

  + main()의 동작이 끝난 후 JRE와 JVM의 동작<br />
    : 메모리 소멸, JVM 기동 중지, JRE가사용한 시스템 자원을 운영체제에 반납.

  + '외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나, 그 역은 가능하다.'<br />
    : A라는 함수 안에 B라는 함수가 존재할 때 A는 B함수의 변수에 접근할 수 없지만, B함수는 A함수의 변수에 접근할 수 있다. (메모리를 그려보면 한 번에 알 수 있다.)

  + Call By Value(값에 의한 전달)<br />
    : 변수가 아닌 변수 값만 복제해서 전달하는 것.

  + 전역 변수를 사용하는 것, 왜 좋지 않을까?
    : 만약 수만 줄이 넘는 코드에서 다른 메서드들에 의해 전역 변수 값이 변화한다면, 코드를 추적해야만 값과 그 값으로 변한 이유를 파악할 수 있다. 즉, 쉽지 않은 작업이다. 읽기 전용으로 값을 공유 해서 전역 상수로 사용하지 않는 한 피하자.
