---
title:  "21.05.10 study"
excerpt: "21.05.10 공부한 키워드 정리"
categories:
  - TIL
  - 백준알고리즘
---

# 📝21.05.10 TIL
+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` ─ 3장. 자바와 객체 지향
  + 다형성(with 생활코딩)
  ```java
  //p.130 예제
  public class Driver {
      public static void main(String[] args) {
        Penguin pororo = new Penguin();
        pororo.name = "뽀로로";
        pronono.habitat = "남극";

        pororo.showName();  //어머 내 이름은 알아서 뭐하게요?
        pororo.showName("소연"); //소연 안녕. 나는 뽀로로라고 해
        pororo.showHabitat(); //뽀로로는 남극에 살아

        Animal pingu = new Penguin();
        pingu.name = "핑구";
        pingu.showName(); //어머 내 이름은 알아서 뭐하게요?
      }
  }
  ```
    + 마지막 'pingu.showName()' 의 결과가 이해가 되지 않아 생활코딩 강의를 들었다. 강의 내용을 토대로 이해해보자면 다음과 같다.<br /><br />
      ```java
      Animal pingu = new Penguin();
      ```
      　pingu는 Penguin 클래스의 인스턴스로 생성되지만 데이터 타입을 Animal로 주었다.(Animal은 Penguin의 상위 클래스이다.) 이때 pingu는 Animal 역할을 하기 때문에 Animal 클래스의 멤버 필드에 접근할 수 있으며, Penguin 클래스의 멤버 필드에는 접근할 수 없다.<br /><br />
      　하지만, Animal 클래스의 showName 메서드를 호출할 때에는 Penguin 클래스에서 오버라이딩 된 showName 메서드의 결과가 반환된다. 오버라이딩 된 메서드의 결과는 왜, 어째서, 어떻게 반환되는 것인가? 하면 솔직히 잘 모르겠다.<br /><br />
      　분명한 것은 Penguin 클래스에서 오버라이딩 되지 않은 메서드는 멤버 필드에 접근할 수 없었던 것처럼 마찬가지로 호출할 수 없다는 것이고, 더불어 오버라이딩 된 메서드의 결과를 반환하는 것이 다형성을 이루게 해준다는 것이다.

<br />

  + 캡슐화 문제 풀이
    + 풀다 보니 내용이 조금 많아서 [여기](https://velog.io/@liv660/%EC%BA%A1%EC%8A%90%ED%99%94-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4)에 기록했다.
    + 풀기 전엔 머리가 지끈거렸는데, 차근차근 풀이하고 나니 대부분이 당연한 결과였다.
    + 확실히 예전보단 접근자에 익숙해진 것 같다! (나중엔 이런 풀이 없이 바로바로 알 수 있기를...!)

<br />

+ 백준 알고리즘 [1110](https://www.acmicpc.net/problem/1110) 풀이 완료

  + 1110 풀이
    + 풀면 풀수록 헷갈리기만 해서 [1110_해설](https://st-lab.tistory.com/42)을 참고해서 풀었다.
    <br/>

  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;

  public class B1110 {

      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

          try {
              int N = Integer.parseInt(br.readLine());
              int init = N;
              int cnt = 0;

              while(true) {
                  N = ((N%10)*10) + (((N/10) + (N%10))%10);
                  cnt++;

                  if(init == N) break;
              }

              System.out.println(cnt);

          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```
  <br />

    + 입력받은 정수 N과, N을 연산하여 얻은 결과를 M이라고 할 때, <br/>
      N의 1의 자리수는 M의 10의 자리수가 되고<br/>
      N의 (10의 자리수 + 1의 자리수) 결괏값이 M의 1의 자리수가 된다.
    + 그럼 M은 다음과 같이 표현할 수 있다.<br />
      M의 10의 자리수 = (N%10)*10 <br />
      M의 1의 자리수 = ((N/10) + (N%10))%10 <br />
      → M = (N%10)*10 + (( (N/10) + (N%10) )%10)
    + M은 다음 연산에서 N이기 때문에 결국  N = (N%10)*10 + (( (N/10) + (N%10) )%10) 이다.
    + 추가로 while문의 종료 지점과 연산 count를 더해주면 풀이가 완성된다.
