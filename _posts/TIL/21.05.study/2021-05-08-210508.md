---
title:  "21.05.08 study"
excerpt: "21.05.08 공부한 키워드 정리"
categories:
  - TIL
---

# 📝21.05.08 TIL
+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` ─ 3장. 자바와 객체 지향
  + 클래스와 객체 개념 바로 알기
    + 사람은 객체일까 클래스일까?
  + 추상화란?
  + 애플리케이션의 경계를 알아내는 방법?
  + 논리적 설계와 물리적 설계 개념
  + main() 메서드는 왜 static일까?
  + 정적 메서드는 어디에서 사용할까?
  + 스태틱 변수, 인스턴스 변수와 달리 지역 변수는 초기화 하지 않으면 왜 쓰레기값을 가질까?
  + 상속 개념 바로 알기
  + 인터페이스 개념 바로 알기

<br />

+ 백준 알고리즘 [10952](https://www.acmicpc.net/problem/10952), [10951](https://www.acmicpc.net/problem/10951) 풀이 완료

  + 10951 풀이<br />
    + 인텔리제이에서는 정상적으로 실행 되었으나, 백준에서는 런타임오류(NullPointer)가 발생했다.<br />

  ```java
  //1. 원래 내가 풀었던 풀이(import, main 생략) ─ NullPointer 발생
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  StringTokenizer st;
  while(true) {
      try {
          st = new StringTokenizer(br.readLine(), " ");
          System.out.println(Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken()));
      } catch (IOException e) {
          e.printStackTrace();
      }
  }
  ```
<br/>

  + [10951_해설](https://st-lab.tistory.com/40)을 참고해보니 EOF 때문에 NullPointer가 발생한 것이었다.<br />
  🌟BufferReader는 입력 데이터가 없을 때 null을 반환한다. 이것을 이용하여 EOF를 설정한다.<br/>

  ```java
  //2. 해설 참고 후 다시 푼 풀이 ─ 136ms로 통과
  import java.io.*;
  import java.util.StringTokenizer;

  public class B10951 {
      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          StringTokenizer st;

          String s;
          try {
              while( (s = br.readLine()) != null) {
                  st = new StringTokenizer(s, " ");
                  System.out.println(Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken()));
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```
<br />

  + StringTokenizer 대신 charAt()을 사용한 풀이<br />
  🌟charAt()은 아스키 코드를 반환하기 때문에 -48 또는 -'0' 을 해줘야 정수값이 반환된다.

  ```java
  import java.io.*;

  public class B10951 {
      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          String s;

          try {
              while((s = br.readLine()) != null) {
                  int A = s.charAt(0) - 48;
                  int B = s.charAt(2) - 48;
                  System.out.println(A+B);
              }
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```
<br />  

+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` check!
  + 클래스와 객체 개념 바로 알기<br />
  : 사람은 클래스이다.클래스는 분류에 대한 개념이지 실체가 아니기 때문.<br />
  : 실체는 객체이다.즉, 유일무이한 사물이다.<br />

  + 추상화란?<br/>
  : 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이다. 즉, 모델링이다.<br/>
    : (🙇🏻‍♀️ 피카소의 추상화를 생각해보자.)

  + 애플리케이션의 경계를 알아내는 방법<br />
    : "내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?" 에 대답해보자.

  + 논리적 설계와 물리적 설계 개념<br />
    : 논리적 설계는 개발 환경(언어 등)에 영향을 받지 않는 설계이다.<br/>
    : 반대로 물리적 설계는 개발 환경에 맞춰진 설계이다.

  + main() 메서드는 왜 static일까?<br />
    : static 멤버들은 객체가 아닌 클래스에 속하기 때문에 JVM 구동 시 T메모리의 Static 영역에 바로 배치된다.<br />
    : 따라서, 객체의 존재 여부에 관계없이 바로 사용이 가능한 것이다.<br />
    : main() 메서드는 클래스 안에 있고, 속한 클래스와 상관없이 실행되기 위해서는 정적 메서드여야만 하는 것이다.

  + 정적 메서드는 어디에서 사용할까? <br />
    : 클래스의 인스턴스를 만들지 않고 사용하게 되는 유틸리티성 메서드로 사용할 수 있다.

  + 스태틱 변수, 인스턴스 변수와 달리 지역 변수는 초기화 하지 않으면 왜 쓰레기값을 가질까? <br />
    : 지역 변수는 한 지역에서만 쓰는 변수이지만, 멤버 변수와 객체 변수는 공유하는 성격을 가지고 있다.<br />
    : 이 공유 변수의 초기화를 누가할 것인지 딱히 규정할 수 없기 때문에 멤버/객체 변수는 별다른 초기화 작업 없이 자동으로 기본값이 설정된다.

  + 상속 개념 바로 알기<br />
    : 객체 지향에서의 상속은 분류를 세분화하는 것이다. 다시말해, 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가하는, 즉 확장해서 사용할 수 있다는 의미다.

  + 인터페이스 개념 바로 알기<br />
    : 구현 클래스 is able to 인터페이스<br />
    : 구현 클래스는 인터페이스 할 수있다.<br />
    : ex. MyThread is able to Runnable ─ MyThread 클래스는 Runnable 할 수 있다.

<br />

+ `스프링 입문을 위한 자바 객체 지향의 원리와 이해` ─ 3장 최종 정리!
  + 추상화
    + OOP에서 추상화는 모델링이다.
    + 클래스 설계 시 추상화가 사용된다.
    + 클래스 설계를 위해서는 애플리케이션 경계부터 정해야한다.
    + <span style="color:red;">객체 지향에서 추상화의 결과는 클래스이다.</span><br />
  + 상속
    + <span style="color:red;">상속은 부모-자식이 아닌 상위 분류-하위 분류 개념의 분류도이다!</span><br />
    + <span style="color:red;">상속을 is a 관계가 아닌 is a kind of 관계로 기억하자.(하위 클래스 is kind of 상위 클래스)</span>
    + 상속은 상위 클래스의 **특성을 재사용**하는 것
    + 상속은 상위 클래스의 **특성을 확장**하는 것
    + 상속은 is a kind of 관계를 만족하는 것<br />
      : 고래 is a kind of 동물 <br/>
      : 고래는 동물의 한 분류다.

## 🤷🏻‍♀️ 다형성. 잘 모르겠다.
## [생활코딩_다형성](https://opentutorials.org/module/516/6127) 으로 다시 공부한 후 정리해보자.
### 내일 할 일: 캡슐화 문제 부분 각 잡고 풀어서 잘 정리해보기
