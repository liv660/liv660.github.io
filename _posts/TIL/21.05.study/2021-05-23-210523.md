---
title:  "21.05.23 기록"
excerpt: "백준 알고리즘(#1152) 풀이 ★StringTokenizer의 countTokens()"
categories:
  - TIL
  - BAEKJOON
---


+ 백준 알고리즘 [1152](https://www.acmicpc.net/problem/1152) 풀이 완료

  + 내가 푼 1152 풀이 (메모리 23.6MB, 시간 292ms로 통과)<br />

  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;

  public class B1152 {
      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          try {
              StringTokenizer st = new StringTokenizer(br.readLine()," ");
              int cnt = 0;

              while(st.hasMoreTokens()) {
                  st.nextToken();
                  cnt++;
              }

              System.out.println(cnt);
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }

  ```
  + StringTokenizer를 사용하여 띄어쓰기를 기준으로 토큰을 저장했다.
  + 이후 while문에서 토큰의 개수를 cnt 변수에 저장한 후, while문을 벗어난 후 cnt 값을 출력하도록 구성했다.
  + 풀고나서 다시 보니 InputStream만으로도 풀 수 있을 것 같아서 다른 풀이를 해보았다.

  <br />

  + 아래는 시도한 다른 코드인데, 테스트 코드에서 오류는 없었으나 백준에서는 오답처리가 됐다.

  ```java
  import java.io.IOException;

  public class B1152 {
      public static void main(String[] args) {
          try {
              //A-Z: 65-90 / a-z: 97-122
              int ch = System.in.read();
              int cnt = 1;

              while(ch != 10) { //개행의 아스키 코드는 10이다.
                  if(ch == 32) cnt++; //띄어쓰기의 아스키 코드는 32이다.
                  ch = System.in.read();
              }

              System.out.println(cnt);
          } catch (IOException e) {
              e.printStackTrace();
          }

      }
  }

  ```

<br />


  + 아래는 [풀이코드](https://st-lab.tistory.com/65)이다.
    + (1)StringTokenizer를 사용한 풀이(메모리 20MB, 시간 304ms로 통과)<br />
      : StringTokenizer 클래스에는 토큰의 개수를 세주는 함수 `countTokens()`가 존재한다. <br/>따로 while문을 할 필요가 없었다!<br />

  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;

  public class B1152 {
      public static void main(String[] args) {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          try {
              StringTokenizer st = new StringTokenizer(br.readLine(), " ");
              System.out.println(st.countTokens());
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

<br />

  + (2)InputStream를 사용한 풀이(메모리 14.1MB, 시간172ms로 통과)<br />
      : 내가 시도했던 풀이와 다르게 이전 문자의 값을 고려하여 카운트 해주었다.<br/>

  ```java
  import java.io.IOException;

  public class B1152 {
    public static void main(String[] args) {
        int cnt = 0;
        int preChar = 32;
        int ch;

        while(true) {
            try {
                ch = System.in.read();

                if(ch == 32) { //입력받은 문자가 공백(띄어쓰기)일 때
                    if(preChar != 32) cnt++;    //이전 문자가 공백이 아니면 cnt++
                } else if (ch == 10) {  //입력받은 문자가 개행일 때
                    if(preChar != 32) cnt++;
                    break;
                }

                preChar = ch;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        System.out.println(cnt);
    }
  }

  ```
